# Отчет по архитектурному аудиту проекта Beauty Salon AI

## Общая информация
- **Дата аудита**: 14 января 2025
- **Размер проекта**: 35 Python файлов в основной части
- **Критический файл**: `dialog_service.py` (805 строк)

---

## 1. Анализ `DialogService.py`

### Текущие обязанности сервиса:

1. **Управление историей диалога** (строки 81-98)
   - Получение истории сообщений из БД
   - Сохранение новых сообщений пользователя и бота
   - Очистка истории диалога

2. **Классификация стадий диалога** (строки 100-113)
   - Вызов ClassificationService для определения стадии
   - Обработка результатов классификации
   - Извлечение персональных данных (имя, телефон)

3. **Управление клиентскими данными** (строки 78-123)
   - Создание/получение клиента по Telegram ID
   - Обновление персональных данных клиента
   - Проверка наличия контактной информации

4. **Формирование системных промптов** (строки 300-390)
   - Построение динамических промптов на основе паттернов
   - Создание fallback промптов
   - Добавление контекстной информации о клиенте

5. **Оркестрация Function Calling** (строки 392-667)
   - Управление циклом генерации с вызовами инструментов
   - Обработка ответов от LLM
   - Выполнение функций через ToolService
   - Обработка специальных случаев (нехватка ПДн, конфликты)

6. **Управление кратковременной памятью** (строки 56-58, 169-229)
   - Хранение показанных записей для каждого пользователя
   - Предоставление контекста для операций с записями

7. **Логирование и отладка** (строки 418-666)
   - Сбор информации об итерациях
   - Логирование вызовов функций
   - Формирование debug-информации

8. **Обработка конфликтных ситуаций** (строки 128-145)
   - Немедленная эскалация на менеджера
   - Специальная обработка конфликтных стадий

### Предлагаемые новые сервисы:

1. **`PromptBuilderService`** - Формирование системных промптов
2. **`FunctionCallOrchestrator`** - Управление циклом Function Calling
3. **`ClientContextService`** - Управление контекстом клиента и ПДн
4. **`DialogMemoryService`** - Управление кратковременной памятью
5. **`ConflictHandlerService`** - Обработка конфликтных ситуаций
6. **`DialogLoggerService`** - Специализированное логирование диалогов

---

## 2. Анализ других "тяжелых" файлов

### `tool_service.py` (560 строк)
**Проблема**: Содержит множество различных обязанностей
- Поиск услуг и мастеров с нечетким совпадением
- Работа с Google Calendar
- Создание и управление записями
- Форматирование данных для LLM

**Решение**: Разделить на:
- `SearchService` - нечеткий поиск услуг/мастеров
- `AppointmentService` - управление записями
- `CalendarIntegrationService` - работа с календарем

### `google_calendar_service.py` (474 строки)
**Проблема**: Смешивает низкоуровневые операции с бизнес-логикой
- Аутентификация и API-вызовы
- Алгоритмы поиска свободных слотов
- Форматирование времени

**Решение**: Разделить на:
- `GoogleCalendarClient` - чистый API-клиент
- `SlotFinderService` - алгоритмы поиска слотов
- `TimeFormatterService` - форматирование времени

### `llm_service.py` (417 строк)
**Проблема**: Поддержка двух провайдеров в одном классе
- Разная логика для Gemini и YandexGPT
- Форматирование ответов
- Управление инструментами

**Решение**: Использовать паттерн Strategy:
- `LLMProviderInterface` - базовый интерфейс
- `GeminiProvider` - реализация для Gemini
- `YandexProvider` - реализация для YandexGPT
- `LLMService` - фасад для выбора провайдера

### `debug_logger.py` (387 строк)
**Проблема**: Слишком много ответственности
- Логирование различных типов событий
- Управление файлами
- Форматирование данных

**Решение**: Разделить на:
- `DialogLogger` - логирование диалогов
- `FunctionCallLogger` - логирование вызовов функций
- `LogFileManager` - управление файлами логов

---

## 3. Общая оценка структуры проекта

### Сильные стороны:

1. **Четкое разделение на слои**: модели, репозитории, сервисы, API
2. **Использование паттерна Repository**: хорошая абстракция доступа к данным
3. **Модульная структура**: логическое разделение по функциональности
4. **Конфигурация через Pydantic**: централизованное управление настройками
5. **Асинхронная архитектура**: правильное использование async/await

### Зоны для улучшения:

1. **Нарушение SRP**: Многие сервисы выполняют несколько обязанностей
2. **Отсутствие Dependency Injection**: Сервисы создаются напрямую в конструкторах
3. **Жесткие связи**: Сервисы знают о конкретных реализациях других сервисов
4. **Дублирование логики**: Похожие алгоритмы в разных местах
5. **Отсутствие интерфейсов**: Нет абстракций для основных сервисов
6. **Смешивание уровней**: Бизнес-логика смешана с техническими деталями

---

## 4. Предлагаемый план рефакторинга (высокоуровневый)

### Этап 1: Разделение DialogService (Приоритет: ВЫСОКИЙ)

1. **Создать `PromptBuilderService`**
   - Вынести методы `_build_dynamic_system_prompt` и `_build_fallback_system_prompt`
   - Добавить интерфейс `IPromptBuilder`

2. **Создать `FunctionCallOrchestrator`**
   - Вынести метод `_execute_generation_cycle`
   - Добавить интерфейс `IFunctionCallOrchestrator`

3. **Создать `ClientContextService`**
   - Вынести логику работы с клиентами и ПДн
   - Добавить интерфейс `IClientContextService`

4. **Создать `DialogMemoryService`**
   - Вынести управление `last_shown_appointments`
   - Добавить интерфейс `IDialogMemoryService`

5. **Упростить `DialogService`**
   - Оставить только роль оркестратора
   - Использовать внедрение зависимостей

### Этап 2: Рефакторинг ToolService (Приоритет: ВЫСОКИЙ)

1. **Создать `SearchService`**
   - Вынести методы нечеткого поиска
   - Добавить интерфейс `ISearchService`

2. **Создать `AppointmentService`**
   - Вынести логику создания/управления записями
   - Добавить интерфейс `IAppointmentService`

3. **Создать `CalendarIntegrationService`**
   - Вынести работу с Google Calendar
   - Добавить интерфейс `ICalendarIntegrationService`

### Этап 3: Рефакторинг LLMService (Приоритет: СРЕДНИЙ)

1. **Создать интерфейс `ILLMProvider`**
2. **Создать `GeminiProvider`** и `YandexProvider`
3. **Упростить `LLMService`** до фасада

### Этап 4: Внедрение Dependency Injection (Приоритет: СРЕДНИЙ)

1. **Создать контейнер зависимостей**
2. **Настроить внедрение для всех сервисов**
3. **Обновить точки создания сервисов**

### Этап 5: Рефакторинг GoogleCalendarService (Приоритет: НИЗКИЙ)

1. **Создать `GoogleCalendarClient`** - чистый API-клиент
2. **Создать `SlotFinderService`** - алгоритмы поиска слотов
3. **Создать `TimeFormatterService`** - форматирование времени

### Этап 6: Рефакторинг DebugLogger (Приоритет: НИЗКИЙ)

1. **Создать специализированные логгеры**
2. **Создать `LogFileManager`**
3. **Упростить основной логгер**

---

## Рекомендации по реализации

1. **Начать с DialogService** - это критический компонент
2. **Использовать интерфейсы** для всех новых сервисов
3. **Тестировать каждый этап** перед переходом к следующему
4. **Сохранять обратную совместимость** во время рефакторинга
5. **Документировать изменения** в архитектуре

---

## Ожидаемые результаты

После рефакторинга:
- **DialogService** станет легким оркестратором (~200 строк)
- **Улучшится тестируемость** - каждый сервис можно тестировать изолированно
- **Упростится расширение** - новые функции добавляются в специализированные сервисы
- **Повысится надежность** - четкое разделение ответственности
- **Улучшится читаемость** - каждый файл будет иметь одну четкую цель
